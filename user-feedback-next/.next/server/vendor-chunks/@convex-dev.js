"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@convex-dev";
exports.ids = ["vendor-chunks/@convex-dev"];
exports.modules = {

/***/ "(ssr)/./node_modules/@convex-dev/auth/dist/react/client.js":
/*!************************************************************!*\
  !*** ./node_modules/@convex-dev/auth/dist/react/client.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   ConvexAuthActionsContext: () => (/* binding */ ConvexAuthActionsContext),\n/* harmony export */   ConvexAuthTokenContext: () => (/* binding */ ConvexAuthTokenContext),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\n\nconst ConvexAuthActionsContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst ConvexAuthInternalContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction useAuth() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ConvexAuthInternalContext);\n}\nconst ConvexAuthTokenContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst VERIFIER_STORAGE_KEY = \"__convexAuthOAuthVerifier\";\nconst JWT_STORAGE_KEY = \"__convexAuthJWT\";\nconst REFRESH_TOKEN_STORAGE_KEY = \"__convexAuthRefreshToken\";\nconst SERVER_STATE_FETCH_TIME_STORAGE_KEY = \"__convexAuthServerStateFetchTime\";\nfunction AuthProvider({ client, serverState, onChange, storage, storageNamespace, replaceURL, children, }) {\n    const token = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(serverState?._state.token ?? null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(token.current === null);\n    const [tokenState, setTokenState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(token.current);\n    const verbose = client.verbose ?? false;\n    const logVerbose = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((message) => {\n        if (verbose) {\n            console.debug(`${new Date().toISOString()} ${message}`);\n        }\n    }, [verbose]);\n    const { storageSet, storageGet, storageRemove, storageKey } = useNamespacedStorage(storage, storageNamespace);\n    const [isRefreshingToken, setIsRefreshingToken] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const setToken = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (args) => {\n        const wasAuthenticated = token.current !== null;\n        let newToken;\n        if (args.tokens === null) {\n            token.current = null;\n            if (args.shouldStore) {\n                await storageRemove(JWT_STORAGE_KEY);\n                await storageRemove(REFRESH_TOKEN_STORAGE_KEY);\n            }\n            newToken = null;\n        }\n        else {\n            const { token: value } = args.tokens;\n            token.current = value;\n            if (args.shouldStore) {\n                const { refreshToken } = args.tokens;\n                await storageSet(JWT_STORAGE_KEY, value);\n                await storageSet(REFRESH_TOKEN_STORAGE_KEY, refreshToken);\n            }\n            newToken = value;\n        }\n        if (wasAuthenticated !== (newToken !== null)) {\n            await onChange?.();\n        }\n        setTokenState(newToken);\n        setIsLoading(false);\n    }, [storageSet, storageRemove]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        const listener = async (e) => {\n            if (isRefreshingToken) {\n                // There are 3 different ways to trigger this pop up so just try all of\n                // them.\n                e.preventDefault();\n                // This confirmation message doesn't actually appear in most modern\n                // browsers but we tried.\n                const confirmationMessage = \"Are you sure you want to leave? Your changes may not be saved.\";\n                e.returnValue = true;\n                return confirmationMessage;\n            }\n        };\n        browserAddEventListener(\"beforeunload\", listener);\n        return () => {\n            browserRemoveEventListener(\"beforeunload\", listener);\n        };\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        // We're listening for:\n        // 1. sibling tabs in case of localStorage\n        // 2. other frames in case of sessionStorage\n        const listener = (event) => {\n            void (async () => {\n                // TODO: Test this if statement works in iframes correctly\n                if (event.storageArea !== storage) {\n                    return;\n                }\n                // Another tab/frame set the access token, use it\n                if (event.key === storageKey(JWT_STORAGE_KEY)) {\n                    const value = event.newValue;\n                    logVerbose(`synced access token, is null: ${value === null}`);\n                    // We don't write into storage since the event came from there and\n                    // we'd trigger a loop, plus we get each key as a separate event so\n                    // we don't have the refresh key here.\n                    await setToken({\n                        shouldStore: false,\n                        tokens: value === null ? null : { token: value },\n                    });\n                }\n            })();\n        };\n        browserAddEventListener(\"storage\", listener);\n        return () => browserRemoveEventListener(\"storage\", listener);\n    }, [setToken]);\n    const verifyCodeAndSetToken = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (args) => {\n        const { tokens } = await client.unauthenticatedCall(\"auth:signIn\", \"code\" in args\n            ? { params: { code: args.code }, verifier: args.verifier }\n            : args);\n        logVerbose(`retrieved tokens, is null: ${tokens === null}`);\n        await setToken({ shouldStore: true, tokens: tokens ?? null });\n        return tokens !== null;\n    }, [client, setToken]);\n    const signIn = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (provider, args) => {\n        const params = args instanceof FormData\n            ? Array.from(args.entries()).reduce((acc, [key, value]) => {\n                acc[key] = value;\n                return acc;\n            }, {})\n            : args ?? {};\n        const verifier = (await storageGet(VERIFIER_STORAGE_KEY)) ?? undefined;\n        await storageRemove(VERIFIER_STORAGE_KEY);\n        const result = await client.authenticatedCall(\"auth:signIn\", { provider, params, verifier });\n        if (result.redirect !== undefined) {\n            const url = new URL(result.redirect);\n            await storageSet(VERIFIER_STORAGE_KEY, result.verifier);\n            // Do not redirect in React Native\n            if (window.location !== undefined) {\n                window.location.href = url.toString();\n            }\n            return { signingIn: false, redirect: url };\n        }\n        else if (result.tokens !== undefined) {\n            const { tokens } = result;\n            logVerbose(`signed in and got tokens, is null: ${tokens === null}`);\n            await setToken({ shouldStore: true, tokens });\n            return { signingIn: result.tokens !== null };\n        }\n        return { signingIn: false };\n    }, [client, setToken, storageGet]);\n    const signOut = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async () => {\n        try {\n            await client.authenticatedCall(\"auth:signOut\");\n        }\n        catch (error) {\n            // Ignore any errors, they are usually caused by being\n            // already signed out, which is ok.\n        }\n        logVerbose(`signed out, erasing tokens`);\n        await setToken({ shouldStore: true, tokens: null });\n    }, [setToken, client]);\n    const fetchAccessToken = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ({ forceRefreshToken }) => {\n        if (forceRefreshToken) {\n            const tokenBeforeLockAquisition = token.current;\n            return await browserMutex(REFRESH_TOKEN_STORAGE_KEY, async () => {\n                const tokenAfterLockAquisition = token.current;\n                // Another tab or frame just refreshed the token, we can use it\n                // and skip another refresh.\n                if (tokenAfterLockAquisition !== tokenBeforeLockAquisition) {\n                    logVerbose(`returning synced token, is null: ${tokenAfterLockAquisition === null}`);\n                    return tokenAfterLockAquisition;\n                }\n                const refreshToken = (await storageGet(REFRESH_TOKEN_STORAGE_KEY)) ?? null;\n                if (refreshToken !== null) {\n                    setIsRefreshingToken(true);\n                    await verifyCodeAndSetToken({ refreshToken }).finally(() => {\n                        setIsRefreshingToken(false);\n                    });\n                    logVerbose(`returning retrieved token, is null: ${tokenAfterLockAquisition === null}`);\n                    return token.current;\n                }\n                else {\n                    setIsRefreshingToken(false);\n                    logVerbose(`returning null, there is no refresh token`);\n                    return null;\n                }\n            });\n        }\n        return token.current;\n    }, [verifyCodeAndSetToken, signOut, storageGet]);\n    const signingInWithCodeFromURL = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        // Has to happen in useEffect to avoid SSR.\n        if (storage === undefined) {\n            throw new Error(\"`localStorage` is not available in this environment, \" +\n                \"set the `storage` prop on `ConvexAuthProvider`!\");\n        }\n        const readStateFromStorage = async () => {\n            const token = (await storageGet(JWT_STORAGE_KEY)) ?? null;\n            logVerbose(`retrieved token from storage, is null: ${token === null}`);\n            await setToken({\n                shouldStore: false,\n                tokens: token === null ? null : { token },\n            });\n        };\n        if (serverState !== undefined) {\n            // First check that this isn't a subsequent render\n            // with stale serverState.\n            const timeFetched = storageGet(SERVER_STATE_FETCH_TIME_STORAGE_KEY);\n            const setTokensFromServerState = (timeFetched) => {\n                if (!timeFetched || serverState._timeFetched > +timeFetched) {\n                    const { token, refreshToken } = serverState._state;\n                    const tokens = token === null || refreshToken === null\n                        ? null\n                        : { token, refreshToken };\n                    void storageSet(SERVER_STATE_FETCH_TIME_STORAGE_KEY, serverState._timeFetched.toString());\n                    void setToken({ tokens, shouldStore: true });\n                }\n                else {\n                    void readStateFromStorage();\n                }\n            };\n            // We want to avoid async if possible.\n            if (timeFetched instanceof Promise) {\n                void timeFetched.then(setTokensFromServerState);\n            }\n            else {\n                setTokensFromServerState(timeFetched);\n            }\n            return;\n        }\n        const code = typeof window?.location !== \"undefined\"\n            ? new URLSearchParams(window.location.search).get(\"code\")\n            : null;\n        // code from URL is only consumed initially,\n        // ref avoids racing in Strict mode\n        if (signingInWithCodeFromURL.current || code) {\n            if (code && !signingInWithCodeFromURL.current) {\n                signingInWithCodeFromURL.current = true;\n                const url = new URL(window.location.href);\n                url.searchParams.delete(\"code\");\n                void (async () => {\n                    await replaceURL(url.pathname + url.search + url.hash);\n                    await signIn(undefined, { code });\n                    signingInWithCodeFromURL.current = false;\n                })();\n            }\n        }\n        else {\n            void readStateFromStorage();\n        }\n    }, \n    // Explicitly chosen dependencies.\n    // This effect should mostly only run once\n    // on mount.\n    [client, storageGet]);\n    const actions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({ signIn, signOut }), [signIn, signOut]);\n    const isAuthenticated = tokenState !== null;\n    const authState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({\n        isLoading,\n        isAuthenticated,\n        fetchAccessToken,\n    }), [fetchAccessToken, isLoading, isAuthenticated]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConvexAuthInternalContext.Provider, { value: authState, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConvexAuthActionsContext.Provider, { value: actions, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConvexAuthTokenContext.Provider, { value: tokenState, children: children }) }) }));\n}\nfunction useNamespacedStorage(peristentStorage, namespace) {\n    const inMemoryStorage = useInMemoryStorage();\n    const storage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => peristentStorage ?? inMemoryStorage(), [peristentStorage]);\n    const escapedNamespace = namespace.replace(/[^a-zA-Z0-9]/g, \"\");\n    const storageKey = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((key) => `${key}_${escapedNamespace}`, [namespace]);\n    const storageSet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((key, value) => storage.setItem(storageKey(key), value), [storage, storageKey]);\n    const storageGet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((key) => storage.getItem(storageKey(key)), [storage, storageKey]);\n    const storageRemove = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((key) => storage.removeItem(storageKey(key)), [storage, storageKey]);\n    return { storageSet, storageGet, storageRemove, storageKey };\n}\nfunction useInMemoryStorage() {\n    const [inMemoryStorage, setInMemoryStorage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    return () => ({\n        getItem: (key) => inMemoryStorage[key],\n        setItem: (key, value) => {\n            setInMemoryStorage((prev) => ({ ...prev, [key]: value }));\n        },\n        removeItem: (key) => {\n            setInMemoryStorage((prev) => {\n                const { [key]: _, ...rest } = prev;\n                return rest;\n            });\n        },\n    });\n}\n// In the browser, executes the callback as the only tab / frame at a time.\nasync function browserMutex(key, callback) {\n    const lockManager = window?.navigator?.locks;\n    return lockManager !== undefined\n        ? await lockManager.request(key, callback)\n        : await manualMutex(key, callback);\n}\nfunction getMutexValue(key) {\n    if (globalThis.__convexAuthMutexes === undefined) {\n        globalThis.__convexAuthMutexes = {};\n    }\n    let mutex = globalThis.__convexAuthMutexes[key];\n    if (mutex === undefined) {\n        globalThis.__convexAuthMutexes[key] = {\n            currentlyRunning: null,\n            waiting: [],\n        };\n    }\n    mutex = globalThis.__convexAuthMutexes[key];\n    return mutex;\n}\nfunction setMutexValue(key, value) {\n    globalThis.__convexAuthMutexes[key] = value;\n}\nasync function enqueueCallbackForMutex(key, callback) {\n    const mutex = getMutexValue(key);\n    if (mutex.currentlyRunning === null) {\n        setMutexValue(key, {\n            currentlyRunning: callback().finally(() => {\n                const nextCb = getMutexValue(key).waiting.shift();\n                getMutexValue(key).currentlyRunning = null;\n                setMutexValue(key, {\n                    ...getMutexValue(key),\n                    currentlyRunning: nextCb === undefined ? null : enqueueCallbackForMutex(key, nextCb),\n                });\n            }),\n            waiting: [],\n        });\n    }\n    else {\n        setMutexValue(key, {\n            ...mutex,\n            waiting: [...mutex.waiting, callback],\n        });\n    }\n}\nasync function manualMutex(key, callback) {\n    const outerPromise = new Promise((resolve, reject) => {\n        const wrappedCallback = () => {\n            return callback()\n                .then((v) => resolve(v))\n                .catch((e) => reject(e));\n        };\n        void enqueueCallbackForMutex(key, wrappedCallback);\n    });\n    return outerPromise;\n}\nfunction browserAddEventListener(type, listener, options) {\n    window.addEventListener?.(type, listener, options);\n}\nfunction browserRemoveEventListener(type, listener, options) {\n    window.removeEventListener?.(type, listener, options);\n}\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbnZleC1kZXYvYXV0aC9kaXN0L3JlYWN0L2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZ0Q7QUFDc0Q7QUFDL0YsaUNBQWlDLG9EQUFhO0FBQ3JELGtDQUFrQyxvREFBYTtBQUN4QztBQUNQLFdBQVcsaURBQVU7QUFDckI7QUFDTywrQkFBK0Isb0RBQWE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDTyx3QkFBd0IsaUZBQWlGO0FBQ2hILGtCQUFrQiw2Q0FBTTtBQUN4QixzQ0FBc0MsK0NBQVE7QUFDOUMsd0NBQXdDLCtDQUFRO0FBQ2hEO0FBQ0EsdUJBQXVCLGtEQUFXO0FBQ2xDO0FBQ0EsNkJBQTZCLDBCQUEwQixFQUFFLFFBQVE7QUFDakU7QUFDQSxLQUFLO0FBQ0wsWUFBWSxvREFBb0Q7QUFDaEUsc0RBQXNELCtDQUFRO0FBQzlELHFCQUFxQixrREFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGVBQWU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxjQUFjO0FBQ3hFLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0NBQWtDLGtEQUFX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Q0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JnZi9wcm9qZWN0cy91c2VyLWZlZWRiYWNrLWFwcGxpY2F0aW9uL3VzZXItZmVlZGJhY2stbmV4dC9ub2RlX21vZHVsZXMvQGNvbnZleC1kZXYvYXV0aC9kaXN0L3JlYWN0L2NsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSwgfSBmcm9tIFwicmVhY3RcIjtcbmV4cG9ydCBjb25zdCBDb252ZXhBdXRoQWN0aW9uc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5jb25zdCBDb252ZXhBdXRoSW50ZXJuYWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUF1dGgoKSB7XG4gICAgcmV0dXJuIHVzZUNvbnRleHQoQ29udmV4QXV0aEludGVybmFsQ29udGV4dCk7XG59XG5leHBvcnQgY29uc3QgQ29udmV4QXV0aFRva2VuQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBWRVJJRklFUl9TVE9SQUdFX0tFWSA9IFwiX19jb252ZXhBdXRoT0F1dGhWZXJpZmllclwiO1xuY29uc3QgSldUX1NUT1JBR0VfS0VZID0gXCJfX2NvbnZleEF1dGhKV1RcIjtcbmNvbnN0IFJFRlJFU0hfVE9LRU5fU1RPUkFHRV9LRVkgPSBcIl9fY29udmV4QXV0aFJlZnJlc2hUb2tlblwiO1xuY29uc3QgU0VSVkVSX1NUQVRFX0ZFVENIX1RJTUVfU1RPUkFHRV9LRVkgPSBcIl9fY29udmV4QXV0aFNlcnZlclN0YXRlRmV0Y2hUaW1lXCI7XG5leHBvcnQgZnVuY3Rpb24gQXV0aFByb3ZpZGVyKHsgY2xpZW50LCBzZXJ2ZXJTdGF0ZSwgb25DaGFuZ2UsIHN0b3JhZ2UsIHN0b3JhZ2VOYW1lc3BhY2UsIHJlcGxhY2VVUkwsIGNoaWxkcmVuLCB9KSB7XG4gICAgY29uc3QgdG9rZW4gPSB1c2VSZWYoc2VydmVyU3RhdGU/Ll9zdGF0ZS50b2tlbiA/PyBudWxsKTtcbiAgICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodG9rZW4uY3VycmVudCA9PT0gbnVsbCk7XG4gICAgY29uc3QgW3Rva2VuU3RhdGUsIHNldFRva2VuU3RhdGVdID0gdXNlU3RhdGUodG9rZW4uY3VycmVudCk7XG4gICAgY29uc3QgdmVyYm9zZSA9IGNsaWVudC52ZXJib3NlID8/IGZhbHNlO1xuICAgIGNvbnN0IGxvZ1ZlcmJvc2UgPSB1c2VDYWxsYmFjaygobWVzc2FnZSkgPT4ge1xuICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9ICR7bWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH0sIFt2ZXJib3NlXSk7XG4gICAgY29uc3QgeyBzdG9yYWdlU2V0LCBzdG9yYWdlR2V0LCBzdG9yYWdlUmVtb3ZlLCBzdG9yYWdlS2V5IH0gPSB1c2VOYW1lc3BhY2VkU3RvcmFnZShzdG9yYWdlLCBzdG9yYWdlTmFtZXNwYWNlKTtcbiAgICBjb25zdCBbaXNSZWZyZXNoaW5nVG9rZW4sIHNldElzUmVmcmVzaGluZ1Rva2VuXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBzZXRUb2tlbiA9IHVzZUNhbGxiYWNrKGFzeW5jIChhcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHdhc0F1dGhlbnRpY2F0ZWQgPSB0b2tlbi5jdXJyZW50ICE9PSBudWxsO1xuICAgICAgICBsZXQgbmV3VG9rZW47XG4gICAgICAgIGlmIChhcmdzLnRva2VucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdG9rZW4uY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYXJncy5zaG91bGRTdG9yZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHN0b3JhZ2VSZW1vdmUoSldUX1NUT1JBR0VfS0VZKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzdG9yYWdlUmVtb3ZlKFJFRlJFU0hfVE9LRU5fU1RPUkFHRV9LRVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VG9rZW4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyB0b2tlbjogdmFsdWUgfSA9IGFyZ3MudG9rZW5zO1xuICAgICAgICAgICAgdG9rZW4uY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKGFyZ3Muc2hvdWxkU3RvcmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlZnJlc2hUb2tlbiB9ID0gYXJncy50b2tlbnM7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3RvcmFnZVNldChKV1RfU1RPUkFHRV9LRVksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzdG9yYWdlU2V0KFJFRlJFU0hfVE9LRU5fU1RPUkFHRV9LRVksIHJlZnJlc2hUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdUb2tlbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3YXNBdXRoZW50aWNhdGVkICE9PSAobmV3VG9rZW4gIT09IG51bGwpKSB7XG4gICAgICAgICAgICBhd2FpdCBvbkNoYW5nZT8uKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VG9rZW5TdGF0ZShuZXdUb2tlbik7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfSwgW3N0b3JhZ2VTZXQsIHN0b3JhZ2VSZW1vdmVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNSZWZyZXNoaW5nVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBhcmUgMyBkaWZmZXJlbnQgd2F5cyB0byB0cmlnZ2VyIHRoaXMgcG9wIHVwIHNvIGp1c3QgdHJ5IGFsbCBvZlxuICAgICAgICAgICAgICAgIC8vIHRoZW0uXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29uZmlybWF0aW9uIG1lc3NhZ2UgZG9lc24ndCBhY3R1YWxseSBhcHBlYXIgaW4gbW9zdCBtb2Rlcm5cbiAgICAgICAgICAgICAgICAvLyBicm93c2VycyBidXQgd2UgdHJpZWQuXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmlybWF0aW9uTWVzc2FnZSA9IFwiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGxlYXZlPyBZb3VyIGNoYW5nZXMgbWF5IG5vdCBiZSBzYXZlZC5cIjtcbiAgICAgICAgICAgICAgICBlLnJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlybWF0aW9uTWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYnJvd3NlckFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgYnJvd3NlclJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgbGlzdGVuZXIpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIFdlJ3JlIGxpc3RlbmluZyBmb3I6XG4gICAgICAgIC8vIDEuIHNpYmxpbmcgdGFicyBpbiBjYXNlIG9mIGxvY2FsU3RvcmFnZVxuICAgICAgICAvLyAyLiBvdGhlciBmcmFtZXMgaW4gY2FzZSBvZiBzZXNzaW9uU3RvcmFnZVxuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdm9pZCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFRlc3QgdGhpcyBpZiBzdGF0ZW1lbnQgd29ya3MgaW4gaWZyYW1lcyBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc3RvcmFnZUFyZWEgIT09IHN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBbm90aGVyIHRhYi9mcmFtZSBzZXQgdGhlIGFjY2VzcyB0b2tlbiwgdXNlIGl0XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gc3RvcmFnZUtleShKV1RfU1RPUkFHRV9LRVkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZXZlbnQubmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGxvZ1ZlcmJvc2UoYHN5bmNlZCBhY2Nlc3MgdG9rZW4sIGlzIG51bGw6ICR7dmFsdWUgPT09IG51bGx9YCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdyaXRlIGludG8gc3RvcmFnZSBzaW5jZSB0aGUgZXZlbnQgY2FtZSBmcm9tIHRoZXJlIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSdkIHRyaWdnZXIgYSBsb29wLCBwbHVzIHdlIGdldCBlYWNoIGtleSBhcyBhIHNlcGFyYXRlIGV2ZW50IHNvXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGhhdmUgdGhlIHJlZnJlc2gga2V5IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNldFRva2VuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFN0b3JlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczogdmFsdWUgPT09IG51bGwgPyBudWxsIDogeyB0b2tlbjogdmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJvd3NlckFkZEV2ZW50TGlzdGVuZXIoXCJzdG9yYWdlXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGJyb3dzZXJSZW1vdmVFdmVudExpc3RlbmVyKFwic3RvcmFnZVwiLCBsaXN0ZW5lcik7XG4gICAgfSwgW3NldFRva2VuXSk7XG4gICAgY29uc3QgdmVyaWZ5Q29kZUFuZFNldFRva2VuID0gdXNlQ2FsbGJhY2soYXN5bmMgKGFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgeyB0b2tlbnMgfSA9IGF3YWl0IGNsaWVudC51bmF1dGhlbnRpY2F0ZWRDYWxsKFwiYXV0aDpzaWduSW5cIiwgXCJjb2RlXCIgaW4gYXJnc1xuICAgICAgICAgICAgPyB7IHBhcmFtczogeyBjb2RlOiBhcmdzLmNvZGUgfSwgdmVyaWZpZXI6IGFyZ3MudmVyaWZpZXIgfVxuICAgICAgICAgICAgOiBhcmdzKTtcbiAgICAgICAgbG9nVmVyYm9zZShgcmV0cmlldmVkIHRva2VucywgaXMgbnVsbDogJHt0b2tlbnMgPT09IG51bGx9YCk7XG4gICAgICAgIGF3YWl0IHNldFRva2VuKHsgc2hvdWxkU3RvcmU6IHRydWUsIHRva2VuczogdG9rZW5zID8/IG51bGwgfSk7XG4gICAgICAgIHJldHVybiB0b2tlbnMgIT09IG51bGw7XG4gICAgfSwgW2NsaWVudCwgc2V0VG9rZW5dKTtcbiAgICBjb25zdCBzaWduSW4gPSB1c2VDYWxsYmFjayhhc3luYyAocHJvdmlkZXIsIGFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gYXJncyBpbnN0YW5jZW9mIEZvcm1EYXRhXG4gICAgICAgICAgICA/IEFycmF5LmZyb20oYXJncy5lbnRyaWVzKCkpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSlcbiAgICAgICAgICAgIDogYXJncyA/PyB7fTtcbiAgICAgICAgY29uc3QgdmVyaWZpZXIgPSAoYXdhaXQgc3RvcmFnZUdldChWRVJJRklFUl9TVE9SQUdFX0tFWSkpID8/IHVuZGVmaW5lZDtcbiAgICAgICAgYXdhaXQgc3RvcmFnZVJlbW92ZShWRVJJRklFUl9TVE9SQUdFX0tFWSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5hdXRoZW50aWNhdGVkQ2FsbChcImF1dGg6c2lnbkluXCIsIHsgcHJvdmlkZXIsIHBhcmFtcywgdmVyaWZpZXIgfSk7XG4gICAgICAgIGlmIChyZXN1bHQucmVkaXJlY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXN1bHQucmVkaXJlY3QpO1xuICAgICAgICAgICAgYXdhaXQgc3RvcmFnZVNldChWRVJJRklFUl9TVE9SQUdFX0tFWSwgcmVzdWx0LnZlcmlmaWVyKTtcbiAgICAgICAgICAgIC8vIERvIG5vdCByZWRpcmVjdCBpbiBSZWFjdCBOYXRpdmVcbiAgICAgICAgICAgIGlmICh3aW5kb3cubG9jYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzaWduaW5nSW46IGZhbHNlLCByZWRpcmVjdDogdXJsIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0LnRva2VucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRva2VucyB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgbG9nVmVyYm9zZShgc2lnbmVkIGluIGFuZCBnb3QgdG9rZW5zLCBpcyBudWxsOiAke3Rva2VucyA9PT0gbnVsbH1gKTtcbiAgICAgICAgICAgIGF3YWl0IHNldFRva2VuKHsgc2hvdWxkU3RvcmU6IHRydWUsIHRva2VucyB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IHNpZ25pbmdJbjogcmVzdWx0LnRva2VucyAhPT0gbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNpZ25pbmdJbjogZmFsc2UgfTtcbiAgICB9LCBbY2xpZW50LCBzZXRUb2tlbiwgc3RvcmFnZUdldF0pO1xuICAgIGNvbnN0IHNpZ25PdXQgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQuYXV0aGVudGljYXRlZENhbGwoXCJhdXRoOnNpZ25PdXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgYW55IGVycm9ycywgdGhleSBhcmUgdXN1YWxseSBjYXVzZWQgYnkgYmVpbmdcbiAgICAgICAgICAgIC8vIGFscmVhZHkgc2lnbmVkIG91dCwgd2hpY2ggaXMgb2suXG4gICAgICAgIH1cbiAgICAgICAgbG9nVmVyYm9zZShgc2lnbmVkIG91dCwgZXJhc2luZyB0b2tlbnNgKTtcbiAgICAgICAgYXdhaXQgc2V0VG9rZW4oeyBzaG91bGRTdG9yZTogdHJ1ZSwgdG9rZW5zOiBudWxsIH0pO1xuICAgIH0sIFtzZXRUb2tlbiwgY2xpZW50XSk7XG4gICAgY29uc3QgZmV0Y2hBY2Nlc3NUb2tlbiA9IHVzZUNhbGxiYWNrKGFzeW5jICh7IGZvcmNlUmVmcmVzaFRva2VuIH0pID0+IHtcbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkJlZm9yZUxvY2tBcXVpc2l0aW9uID0gdG9rZW4uY3VycmVudDtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBicm93c2VyTXV0ZXgoUkVGUkVTSF9UT0tFTl9TVE9SQUdFX0tFWSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuQWZ0ZXJMb2NrQXF1aXNpdGlvbiA9IHRva2VuLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgLy8gQW5vdGhlciB0YWIgb3IgZnJhbWUganVzdCByZWZyZXNoZWQgdGhlIHRva2VuLCB3ZSBjYW4gdXNlIGl0XG4gICAgICAgICAgICAgICAgLy8gYW5kIHNraXAgYW5vdGhlciByZWZyZXNoLlxuICAgICAgICAgICAgICAgIGlmICh0b2tlbkFmdGVyTG9ja0FxdWlzaXRpb24gIT09IHRva2VuQmVmb3JlTG9ja0FxdWlzaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nVmVyYm9zZShgcmV0dXJuaW5nIHN5bmNlZCB0b2tlbiwgaXMgbnVsbDogJHt0b2tlbkFmdGVyTG9ja0FxdWlzaXRpb24gPT09IG51bGx9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkFmdGVyTG9ja0FxdWlzaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbiA9IChhd2FpdCBzdG9yYWdlR2V0KFJFRlJFU0hfVE9LRU5fU1RPUkFHRV9LRVkpKSA/PyBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZWZyZXNoVG9rZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0SXNSZWZyZXNoaW5nVG9rZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHZlcmlmeUNvZGVBbmRTZXRUb2tlbih7IHJlZnJlc2hUb2tlbiB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldElzUmVmcmVzaGluZ1Rva2VuKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ1ZlcmJvc2UoYHJldHVybmluZyByZXRyaWV2ZWQgdG9rZW4sIGlzIG51bGw6ICR7dG9rZW5BZnRlckxvY2tBcXVpc2l0aW9uID09PSBudWxsfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4uY3VycmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldElzUmVmcmVzaGluZ1Rva2VuKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nVmVyYm9zZShgcmV0dXJuaW5nIG51bGwsIHRoZXJlIGlzIG5vIHJlZnJlc2ggdG9rZW5gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuLmN1cnJlbnQ7XG4gICAgfSwgW3ZlcmlmeUNvZGVBbmRTZXRUb2tlbiwgc2lnbk91dCwgc3RvcmFnZUdldF0pO1xuICAgIGNvbnN0IHNpZ25pbmdJbldpdGhDb2RlRnJvbVVSTCA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gSGFzIHRvIGhhcHBlbiBpbiB1c2VFZmZlY3QgdG8gYXZvaWQgU1NSLlxuICAgICAgICBpZiAoc3RvcmFnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgbG9jYWxTdG9yYWdlYCBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQsIFwiICtcbiAgICAgICAgICAgICAgICBcInNldCB0aGUgYHN0b3JhZ2VgIHByb3Agb24gYENvbnZleEF1dGhQcm92aWRlcmAhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlYWRTdGF0ZUZyb21TdG9yYWdlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSAoYXdhaXQgc3RvcmFnZUdldChKV1RfU1RPUkFHRV9LRVkpKSA/PyBudWxsO1xuICAgICAgICAgICAgbG9nVmVyYm9zZShgcmV0cmlldmVkIHRva2VuIGZyb20gc3RvcmFnZSwgaXMgbnVsbDogJHt0b2tlbiA9PT0gbnVsbH1gKTtcbiAgICAgICAgICAgIGF3YWl0IHNldFRva2VuKHtcbiAgICAgICAgICAgICAgICBzaG91bGRTdG9yZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0b2tlbiA9PT0gbnVsbCA/IG51bGwgOiB7IHRva2VuIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNlcnZlclN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIHRoYXQgdGhpcyBpc24ndCBhIHN1YnNlcXVlbnQgcmVuZGVyXG4gICAgICAgICAgICAvLyB3aXRoIHN0YWxlIHNlcnZlclN0YXRlLlxuICAgICAgICAgICAgY29uc3QgdGltZUZldGNoZWQgPSBzdG9yYWdlR2V0KFNFUlZFUl9TVEFURV9GRVRDSF9USU1FX1NUT1JBR0VfS0VZKTtcbiAgICAgICAgICAgIGNvbnN0IHNldFRva2Vuc0Zyb21TZXJ2ZXJTdGF0ZSA9ICh0aW1lRmV0Y2hlZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGltZUZldGNoZWQgfHwgc2VydmVyU3RhdGUuX3RpbWVGZXRjaGVkID4gK3RpbWVGZXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9rZW4sIHJlZnJlc2hUb2tlbiB9ID0gc2VydmVyU3RhdGUuX3N0YXRlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbnMgPSB0b2tlbiA9PT0gbnVsbCB8fCByZWZyZXNoVG9rZW4gPT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IHRva2VuLCByZWZyZXNoVG9rZW4gfTtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCBzdG9yYWdlU2V0KFNFUlZFUl9TVEFURV9GRVRDSF9USU1FX1NUT1JBR0VfS0VZLCBzZXJ2ZXJTdGF0ZS5fdGltZUZldGNoZWQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgc2V0VG9rZW4oeyB0b2tlbnMsIHNob3VsZFN0b3JlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCByZWFkU3RhdGVGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBXZSB3YW50IHRvIGF2b2lkIGFzeW5jIGlmIHBvc3NpYmxlLlxuICAgICAgICAgICAgaWYgKHRpbWVGZXRjaGVkIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHZvaWQgdGltZUZldGNoZWQudGhlbihzZXRUb2tlbnNGcm9tU2VydmVyU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VG9rZW5zRnJvbVNlcnZlclN0YXRlKHRpbWVGZXRjaGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlID0gdHlwZW9mIHdpbmRvdz8ubG9jYXRpb24gIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKS5nZXQoXCJjb2RlXCIpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIC8vIGNvZGUgZnJvbSBVUkwgaXMgb25seSBjb25zdW1lZCBpbml0aWFsbHksXG4gICAgICAgIC8vIHJlZiBhdm9pZHMgcmFjaW5nIGluIFN0cmljdCBtb2RlXG4gICAgICAgIGlmIChzaWduaW5nSW5XaXRoQ29kZUZyb21VUkwuY3VycmVudCB8fCBjb2RlKSB7XG4gICAgICAgICAgICBpZiAoY29kZSAmJiAhc2lnbmluZ0luV2l0aENvZGVGcm9tVVJMLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBzaWduaW5nSW5XaXRoQ29kZUZyb21VUkwuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJjb2RlXCIpO1xuICAgICAgICAgICAgICAgIHZvaWQgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVwbGFjZVVSTCh1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgdXJsLmhhc2gpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzaWduSW4odW5kZWZpbmVkLCB7IGNvZGUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25pbmdJbldpdGhDb2RlRnJvbVVSTC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZvaWQgcmVhZFN0YXRlRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgfVxuICAgIH0sIFxuICAgIC8vIEV4cGxpY2l0bHkgY2hvc2VuIGRlcGVuZGVuY2llcy5cbiAgICAvLyBUaGlzIGVmZmVjdCBzaG91bGQgbW9zdGx5IG9ubHkgcnVuIG9uY2VcbiAgICAvLyBvbiBtb3VudC5cbiAgICBbY2xpZW50LCBzdG9yYWdlR2V0XSk7XG4gICAgY29uc3QgYWN0aW9ucyA9IHVzZU1lbW8oKCkgPT4gKHsgc2lnbkluLCBzaWduT3V0IH0pLCBbc2lnbkluLCBzaWduT3V0XSk7XG4gICAgY29uc3QgaXNBdXRoZW50aWNhdGVkID0gdG9rZW5TdGF0ZSAhPT0gbnVsbDtcbiAgICBjb25zdCBhdXRoU3RhdGUgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgaXNBdXRoZW50aWNhdGVkLFxuICAgICAgICBmZXRjaEFjY2Vzc1Rva2VuLFxuICAgIH0pLCBbZmV0Y2hBY2Nlc3NUb2tlbiwgaXNMb2FkaW5nLCBpc0F1dGhlbnRpY2F0ZWRdKTtcbiAgICByZXR1cm4gKF9qc3goQ29udmV4QXV0aEludGVybmFsQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogYXV0aFN0YXRlLCBjaGlsZHJlbjogX2pzeChDb252ZXhBdXRoQWN0aW9uc0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGFjdGlvbnMsIGNoaWxkcmVuOiBfanN4KENvbnZleEF1dGhUb2tlbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRva2VuU3RhdGUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSB9KSk7XG59XG5mdW5jdGlvbiB1c2VOYW1lc3BhY2VkU3RvcmFnZShwZXJpc3RlbnRTdG9yYWdlLCBuYW1lc3BhY2UpIHtcbiAgICBjb25zdCBpbk1lbW9yeVN0b3JhZ2UgPSB1c2VJbk1lbW9yeVN0b3JhZ2UoKTtcbiAgICBjb25zdCBzdG9yYWdlID0gdXNlTWVtbygoKSA9PiBwZXJpc3RlbnRTdG9yYWdlID8/IGluTWVtb3J5U3RvcmFnZSgpLCBbcGVyaXN0ZW50U3RvcmFnZV0pO1xuICAgIGNvbnN0IGVzY2FwZWROYW1lc3BhY2UgPSBuYW1lc3BhY2UucmVwbGFjZSgvW15hLXpBLVowLTldL2csIFwiXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB1c2VDYWxsYmFjaygoa2V5KSA9PiBgJHtrZXl9XyR7ZXNjYXBlZE5hbWVzcGFjZX1gLCBbbmFtZXNwYWNlXSk7XG4gICAgY29uc3Qgc3RvcmFnZVNldCA9IHVzZUNhbGxiYWNrKChrZXksIHZhbHVlKSA9PiBzdG9yYWdlLnNldEl0ZW0oc3RvcmFnZUtleShrZXkpLCB2YWx1ZSksIFtzdG9yYWdlLCBzdG9yYWdlS2V5XSk7XG4gICAgY29uc3Qgc3RvcmFnZUdldCA9IHVzZUNhbGxiYWNrKChrZXkpID0+IHN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KGtleSkpLCBbc3RvcmFnZSwgc3RvcmFnZUtleV0pO1xuICAgIGNvbnN0IHN0b3JhZ2VSZW1vdmUgPSB1c2VDYWxsYmFjaygoa2V5KSA9PiBzdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleShrZXkpKSwgW3N0b3JhZ2UsIHN0b3JhZ2VLZXldKTtcbiAgICByZXR1cm4geyBzdG9yYWdlU2V0LCBzdG9yYWdlR2V0LCBzdG9yYWdlUmVtb3ZlLCBzdG9yYWdlS2V5IH07XG59XG5mdW5jdGlvbiB1c2VJbk1lbW9yeVN0b3JhZ2UoKSB7XG4gICAgY29uc3QgW2luTWVtb3J5U3RvcmFnZSwgc2V0SW5NZW1vcnlTdG9yYWdlXSA9IHVzZVN0YXRlKHt9KTtcbiAgICByZXR1cm4gKCkgPT4gKHtcbiAgICAgICAgZ2V0SXRlbTogKGtleSkgPT4gaW5NZW1vcnlTdG9yYWdlW2tleV0sXG4gICAgICAgIHNldEl0ZW06IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBzZXRJbk1lbW9yeVN0b3JhZ2UoKHByZXYpID0+ICh7IC4uLnByZXYsIFtrZXldOiB2YWx1ZSB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUl0ZW06IChrZXkpID0+IHtcbiAgICAgICAgICAgIHNldEluTWVtb3J5U3RvcmFnZSgocHJldikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgW2tleV06IF8sIC4uLnJlc3QgfSA9IHByZXY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8vIEluIHRoZSBicm93c2VyLCBleGVjdXRlcyB0aGUgY2FsbGJhY2sgYXMgdGhlIG9ubHkgdGFiIC8gZnJhbWUgYXQgYSB0aW1lLlxuYXN5bmMgZnVuY3Rpb24gYnJvd3Nlck11dGV4KGtleSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBsb2NrTWFuYWdlciA9IHdpbmRvdz8ubmF2aWdhdG9yPy5sb2NrcztcbiAgICByZXR1cm4gbG9ja01hbmFnZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGF3YWl0IGxvY2tNYW5hZ2VyLnJlcXVlc3Qoa2V5LCBjYWxsYmFjaylcbiAgICAgICAgOiBhd2FpdCBtYW51YWxNdXRleChrZXksIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGdldE11dGV4VmFsdWUoa2V5KSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuX19jb252ZXhBdXRoTXV0ZXhlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdsb2JhbFRoaXMuX19jb252ZXhBdXRoTXV0ZXhlcyA9IHt9O1xuICAgIH1cbiAgICBsZXQgbXV0ZXggPSBnbG9iYWxUaGlzLl9fY29udmV4QXV0aE11dGV4ZXNba2V5XTtcbiAgICBpZiAobXV0ZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnbG9iYWxUaGlzLl9fY29udmV4QXV0aE11dGV4ZXNba2V5XSA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmc6IG51bGwsXG4gICAgICAgICAgICB3YWl0aW5nOiBbXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbXV0ZXggPSBnbG9iYWxUaGlzLl9fY29udmV4QXV0aE11dGV4ZXNba2V5XTtcbiAgICByZXR1cm4gbXV0ZXg7XG59XG5mdW5jdGlvbiBzZXRNdXRleFZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBnbG9iYWxUaGlzLl9fY29udmV4QXV0aE11dGV4ZXNba2V5XSA9IHZhbHVlO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5xdWV1ZUNhbGxiYWNrRm9yTXV0ZXgoa2V5LCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG11dGV4ID0gZ2V0TXV0ZXhWYWx1ZShrZXkpO1xuICAgIGlmIChtdXRleC5jdXJyZW50bHlSdW5uaW5nID09PSBudWxsKSB7XG4gICAgICAgIHNldE11dGV4VmFsdWUoa2V5LCB7XG4gICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nOiBjYWxsYmFjaygpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDYiA9IGdldE11dGV4VmFsdWUoa2V5KS53YWl0aW5nLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgZ2V0TXV0ZXhWYWx1ZShrZXkpLmN1cnJlbnRseVJ1bm5pbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNldE11dGV4VmFsdWUoa2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmdldE11dGV4VmFsdWUoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZzogbmV4dENiID09PSB1bmRlZmluZWQgPyBudWxsIDogZW5xdWV1ZUNhbGxiYWNrRm9yTXV0ZXgoa2V5LCBuZXh0Q2IpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB3YWl0aW5nOiBbXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRNdXRleFZhbHVlKGtleSwge1xuICAgICAgICAgICAgLi4ubXV0ZXgsXG4gICAgICAgICAgICB3YWl0aW5nOiBbLi4ubXV0ZXgud2FpdGluZywgY2FsbGJhY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBtYW51YWxNdXRleChrZXksIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgb3V0ZXJQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICAgICAgICAgIC50aGVuKCh2KSA9PiByZXNvbHZlKHYpKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4gcmVqZWN0KGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdm9pZCBlbnF1ZXVlQ2FsbGJhY2tGb3JNdXRleChrZXksIHdyYXBwZWRDYWxsYmFjayk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dGVyUHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGJyb3dzZXJBZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXI/Lih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBicm93c2VyUmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyPy4odHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@convex-dev/auth/dist/react/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@convex-dev/auth/dist/react/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@convex-dev/auth/dist/react/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConvexAuthProvider: () => (/* binding */ ConvexAuthProvider),\n/* harmony export */   useAuthActions: () => (/* binding */ useAuthActions),\n/* harmony export */   useAuthToken: () => (/* binding */ useAuthToken)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var convex_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! convex/browser */ \"(ssr)/./node_modules/convex/dist/esm/browser/index-node.js\");\n/* harmony import */ var convex_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! convex/react */ \"(ssr)/./node_modules/convex/dist/esm/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./client.js */ \"(ssr)/./node_modules/@convex-dev/auth/dist/react/client.js\");\n/**\n * React bindings for Convex Auth.\n *\n * @module\n */ /* __next_internal_client_entry_do_not_use__ useAuthActions,ConvexAuthProvider,useAuthToken auto */ \n\n\n\n\n/**\n * Use this hook to access the `signIn` and `signOut` methods:\n *\n * ```ts\n * import { useAuthActions } from \"@convex-dev/auth/react\";\n *\n * function SomeComponent() {\n *   const { signIn, signOut } = useAuthActions();\n *   // ...\n * }\n * ```\n */ function useAuthActions() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(_client_js__WEBPACK_IMPORTED_MODULE_4__.ConvexAuthActionsContext);\n}\n/**\n * Replace your `ConvexProvider` with this component to enable authentication.\n *\n * ```tsx\n * import { ConvexAuthProvider } from \"@convex-dev/auth/react\";\n * import { ConvexReactClient } from \"convex/react\";\n * import { ReactNode } from \"react\";\n *\n * const convex = new ConvexReactClient(/* ... *\\/);\n *\n * function RootComponent({ children }: { children: ReactNode }) {\n *   return <ConvexAuthProvider client={convex}>{children}</ConvexAuthProvider>;\n * }\n * ```\n */ function ConvexAuthProvider(props) {\n    const { client, storage, storageNamespace, replaceURL, children } = props;\n    const authClient = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"ConvexAuthProvider.useMemo[authClient]\": ()=>({\n                authenticatedCall (action, args) {\n                    return client.action(action, args);\n                },\n                unauthenticatedCall (action, args) {\n                    return new convex_browser__WEBPACK_IMPORTED_MODULE_1__.ConvexHttpClient(client.address).action(action, args);\n                },\n                verbose: client.options?.verbose\n            })\n    }[\"ConvexAuthProvider.useMemo[authClient]\"], [\n        client\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_client_js__WEBPACK_IMPORTED_MODULE_4__.AuthProvider, {\n        client: authClient,\n        storage: storage ?? // Handle SSR, RN, Web, etc.\n        // Pretend we always have storage, the component checks\n        // it in first useEffect.\n        ( true ? undefined : 0),\n        storageNamespace: storageNamespace ?? client.address,\n        replaceURL: replaceURL ?? ((url)=>{\n            window.history.replaceState({}, \"\", url);\n        }),\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(convex_react__WEBPACK_IMPORTED_MODULE_2__.ConvexProviderWithAuth, {\n            client: client,\n            useAuth: _client_js__WEBPACK_IMPORTED_MODULE_4__.useAuth,\n            children: children\n        })\n    });\n}\n/**\n * Use this hook to access the JWT token on the client, for authenticating\n * your Convex HTTP actions.\n *\n * You should not pass this token to other servers (think of it\n * as an \"ID token\").\n *\n * ```ts\n * import { useAuthToken } from \"@convex-dev/auth/react\";\n *\n * function SomeComponent() {\n *   const token = useAuthToken();\n *   const onClick = async () => {\n *     await fetch(`${CONVEX_SITE_URL}/someEndpoint`, {\n *       headers: {\n *         Authorization: `Bearer ${token}`,\n *       },\n *     });\n *   };\n *   // ...\n * }\n * ```\n */ function useAuthToken() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(_client_js__WEBPACK_IMPORTED_MODULE_4__.ConvexAuthTokenContext);\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbnZleC1kZXYvYXV0aC9kaXN0L3JlYWN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7Ozs7R0FJRztBQUkrQztBQUN1QjtBQUVsQjtBQU1sQztBQUdyQjs7Ozs7Ozs7Ozs7R0FXRyxDQUNHLFNBQVUsY0FBYztJQUM1QixPQUFPLGlEQUFVLENBQUMsZ0VBQXdCLENBQUMsQ0FBQztBQUM5QyxDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7O0dBY0csQ0FDRyxTQUFVLGtCQUFrQixDQUFDLEtBMENsQztJQUNDLE1BQU0sRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsR0FBRyxLQUFLLENBQUM7SUFDMUUsTUFBTSxVQUFVLEdBQUcsOENBQU87a0RBQ3hCLEdBQUcsRUFBRSxDQUNIO2dCQUNFLGlCQUFpQixFQUFDLE1BQU0sRUFBRSxJQUFJO29CQUM1QixPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUNyQyxDQUFDO2dCQUNELG1CQUFtQixFQUFDLE1BQU0sRUFBRSxJQUFJO29CQUM5QixPQUFPLElBQUksNERBQWdCLENBQUUsTUFBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FDekQsTUFBTSxFQUNOLElBQUksQ0FDTCxDQUFDO2dCQUNKLENBQUM7Z0JBQ0QsT0FBTyxFQUFHLE1BQWMsQ0FBQyxPQUFPLEVBQUUsT0FBTztjQUMxQztpREFDSDtRQUFDLE1BQU07S0FBQyxDQUNULENBQUM7SUFDRixPQUFPLHVEQUNKLG9EQUFZO1FBQ1gsTUFBTSxFQUFFLFVBQVU7UUFDbEIsT0FBTyxFQUNMLE9BQU8sSUFDUCw0QkFBNEI7UUFDNUIsdURBQXVEO1FBQ3ZELHlCQUF5QjtTQUN4QixLQUE2QixDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQVEsQ0FBWSxDQUFFO1FBRXJFLGdCQUFnQixFQUFFLGdCQUFnQixJQUFLLE1BQWMsQ0FBQyxPQUFPO1FBQzdELFVBQVUsRUFDUixVQUFVLEtBQ1QsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUNQLE1BQU0sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUM7U0FDM0MsQ0FBQyxDQUFDO1FBQUEsVUFHSix1REFBQyxnRUFBc0I7WUFBQyxNQUFNLEVBQUUsTUFBTTtZQUFFLE9BQU8sRUFBRSwrQ0FBTztZQUFBLFVBQ3JELFFBQVE7UUFBQSxFQUNjO0lBQUEsRUFDWixDQUNoQjtBQUNILENBQUM7QUEwR0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FzQkcsQ0FDRyxTQUFVLFlBQVk7SUFDMUIsT0FBTyxpREFBVSxDQUFDLDhEQUFzQixDQUFDLENBQUM7QUFDNUMsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2JnZi9wcm9qZWN0cy9zcmMvcmVhY3QvaW5kZXgudHN4Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@convex-dev/auth/dist/react/index.js\n");

/***/ })

};
;